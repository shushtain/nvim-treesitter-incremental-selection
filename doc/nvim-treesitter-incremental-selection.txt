*nvim-treesitter-incremental-selection*       Treesitter Incremental Selection

                                       Type |gO| to see the table of contents.

==============================================================================
INTRODUCTION                     *nvim-treesitter-incremental-selection-intro*

People who switch to the `main` branch of `nvim-treesitter` might notice that
it aims to remove modules, such as `incremental_selection`.

This plugin aims to bring it back and more.

==============================================================================
SETUP                            *nvim-treesitter-incremental-selection-setup*

With Lazy and config defaults:

>
    return {
      "shushtain/nvim-treesitter-incremental-selection",
      config = function()
        local tsis = require("nvim-treesitter-incremental-selection")

        ---@type TSIS.Config
        tsis.setup({
          ignore_injections = false,
          loop_siblings = false,
          fallback = false,
          quiet = false,
        })
      end
    }
<

==============================================================================
OPTIONS                           *nvim-treesitter-incremental-selection-opts*

                *nvim-treesitter-incremental-selection-opts#ignore_injections*
ignore_injections ~

If `true`, ignore language injections while selecting nodes.
This will treat injected code blocks as single nodes without children.

For example:

If this setting is `false`, incrementing selection within a Markdown code block
selects a node from injected language. If this is `true`, the same action
selects the whole code block, as a Markdown node, disregarding injected nodes.

                    *nvim-treesitter-incremental-selection-opts#loop_siblings*
loop_siblings ~

If `true`, last child will have first child as next sibling, and vice versa.

For example:

You select one of key-value pairs within a table. If this setting is `true`,
calling `next_sibling` on the last pair would jump-select the first pair.
Calling `prev_sibling` on the first pair would jump-select the last pair.
If this setting is `false`, calling those functions would do nothing
in those cases.

                         *nvim-treesitter-incremental-selection-opts#fallback*
fallback ~

If `true` and Treesitter is not active, will select inside Word instead (`viW`).

                            *nvim-treesitter-incremental-selection-opts#quiet*
quiet ~

If `true` and Treesitter is not active, will not show warning.

==============================================================================
USAGE                            *nvim-treesitter-incremental-selection-usage*

This plugin doesn't set any keymaps by default.

                        *nvim-treesitter-incremental-selection#init_selection*
                        *nvim-treesitter-incremental-selection#increment_node*
                        *nvim-treesitter-incremental-selection#decrement_node*

You may be familiar with `init_selection`, `node_incremental`, `node_decremental`
from the `master` branch of `nvim-treesitter`. These have slightly different names
but act in similar fashion. `scope_incremental` is not implemented (for now?).

Use this commands:

>
    local tsis = require("nvim-treesitter-incremental-selection")
    vim.keymap.set("n", "<shortcut>", tsis.init_selection)
    vim.keymap.set("v", "<shortcut>", tsis.increment_node)
    vim.keymap.set("v", "<shortcut>", tsis.decrement_node)
<

                          *nvim-treesitter-incremental-selection#next_sibling*
                          *nvim-treesitter-incremental-selection#prev_sibling*
                                 *nvim-treesitter-incremental-selection#child*

There were no `next_sibling`, `prev_sibling` or `child` in the original
implementation. One of good reasons for that is that they break the original
flow (after switching to siblings or children, `decrement_node` chain
must be emptied). But still, you may want to use them occasionally.

Use this commands:

>
    local tsis = require("nvim-treesitter-incremental-selection")
    vim.keymap.set("v", "<shortcut>", tsis.next_sibling)
    vim.keymap.set("v", "<shortcut>", tsis.prev_sibling)
    vim.keymap.set("v", "<shortcut>", tsis.child) -- first child
    vim.keymap.set("v", "<shortcut>", function()
      tsis.child()   -- first child
      tsis.child(0)  -- first child
      tsis.child(1)  -- first child

      tsis.child(6)  -- sixth child
      tsis.child(-1) -- last child
      tsis.child(-3) -- third child from the right
    end)
<

Children use 1-based indexing. To count backwards, use negative numbers.
`0` falls back to `1`. If positive or negative index goes past the child count,
the last child from that direction is chosen.


vim:tw=78:ts=8:expandtab:noet:ft=help:norl:
